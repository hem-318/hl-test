name: Azure Multi-Region Latency Test

on:
  workflow_dispatch: # Manual trigger via GitHub UI
    inputs:
      test_regions:
        description: 'Comma-separated list of regions to test (leave empty for all regions)'
        required: false
        default: ''
      sequential_mode:
        description: 'Run tests sequentially (one region at a time)'
        required: false
        default: true
        type: boolean
  schedule:
    - cron: '0 2 * * 1' # Run weekly on Monday at 2 AM UTC

env:
  RESOURCE_GROUP: latency-test-rg
  VM_IMAGE: Canonical:0001-com-ubuntu-server-jammy:22_04-lts-gen2:latest
  REDIS_URL: ${{ secrets.REDIS_URL }}
  PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      regions: ${{ steps.get-regions.outputs.regions }}
      sequential: ${{ steps.get-regions.outputs.sequential }}
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }
      
      - name: Create Resource Group
        run: |
          az group create --name ${{ env.RESOURCE_GROUP }} --location centralus || echo "Resource group already exists"
      
      - name: Get Azure Regions
        id: get-regions
        run: |
          # List of regions that support VirtualNetworks (from the error message)
          VNET_REGIONS='westus,eastus,northeurope,westeurope,eastasia,southeastasia,northcentralus,southcentralus,centralus,eastus2,japaneast,japanwest,brazilsouth,australiaeast,australiasoutheast,centralindia,southindia,westindia,canadacentral,canadaeast,westcentralus,westus2,ukwest,uksouth,koreacentral,koreasouth,francecentral,australiacentral,southafricanorth,uaenorth,switzerlandnorth,germanywestcentral,norwayeast,westus3,jioindiawest,swedencentral,qatarcentral,polandcentral,italynorth,israelcentral,mexicocentral,spaincentral,newzealandnorth,indonesiacentral,chilecentral,malaysiawest,austriaeast'
          
          if [ -n "${{ github.event.inputs.test_regions }}" ]; then
            # Use manually specified regions, but filter to only those that support VNets
            REGIONS='${{ github.event.inputs.test_regions }}'
            REGIONS_JSON=$(echo $REGIONS | jq -R -s -c --arg vnet_regions "$VNET_REGIONS" '
              split(",") | map(gsub("\\s+"; "")) | 
              map(select(. as $r | $vnet_regions | split(",") | index($r)))
            ')
          else
            # Get all available regions that support both VMs and VirtualNetworks
            ALL_REGIONS=$(az account list-locations --query "[?metadata.regionType=='Physical' && metadata.physicalLocation!=null].name" -o json)
            REGIONS_JSON=$(echo "$ALL_REGIONS" | jq -c --arg vnet_regions "$VNET_REGIONS" '
              map(select(. as $r | $vnet_regions | split(",") | index($r))) | sort
            ')
          fi
          
          # Determine if sequential mode is enabled
          SEQUENTIAL="${{ github.event.inputs.sequential_mode }}"
          if [ -z "$SEQUENTIAL" ]; then
            SEQUENTIAL="true"  # Default to sequential
          fi
          
          echo "regions=$REGIONS_JSON" >> $GITHUB_OUTPUT
          echo "sequential=$SEQUENTIAL" >> $GITHUB_OUTPUT
          echo "Testing regions: $REGIONS_JSON"
          echo "Sequential mode: $SEQUENTIAL"
          echo "Note: Filtered to regions that support VirtualNetworks"

  latency-test:
    needs: [setup]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: ${{ needs.setup.outputs.sequential == 'true' && 1 || 10 }}
      matrix:
        region: ${{ fromJson(needs.setup.outputs.regions) }}
    timeout-minutes: 30
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }
      
      - name: Pick best VM size for ${{ matrix.region }}
        id: pick-size
        shell: bash
        env:
          REGION: ${{ matrix.region }}
        run: |
          set -euo pipefail

          # Discover available SKUs for VMs in this region
          SKUS_JSON=$(az vm list-skus --location "$REGION" --resource-type virtualMachines --all -o json)

          # Save to temp file to avoid pipe issues
          echo "$SKUS_JSON" > _skus.json
          
          # Build a table of candidate SKUs with capabilities we care about
          jq -r --argjson pref '[
            "Standard_F4s_v2","Standard_D4ds_v5","Standard_D4s_v5",
            "Standard_D4s_v3","Standard_F4s","Standard_D4as_v5"
          ]' '
            def cap($n): 
              if .capabilities == null then empty
              else (.capabilities | map(select(.name == $n)) | if length > 0 then .[0].value else empty end)
              end;
            def has_location_restriction:
              (.restrictions // []) | map(select(.type == "Location")) | length > 0;
            [.[] | 
             select(.resourceType=="virtualMachines" and .name != null and (has_location_restriction | not)) | 
             {
               name: .name,
               vcpus: (cap("vCPUs") | tonumber? // 0),
               mem: (cap("MemoryGB") | tonumber? // 0),
               premium: ((cap("PremiumIO") | ascii_downcase) == "true"),
               an: ((cap("AcceleratedNetworkingEnabled") | ascii_downcase) == "true")
             } | 
             select(.vcpus >= 4 and .mem >= 8)
            ] as $all |
            ($pref | map(. as $p | ($all | map(select(.name==$p.name)))[0] // empty)) as $preferred |
            ($all | map(select([.name] | inside($preferred | map(.name)) | not)) | 
             sort_by((if .an then 0 else 1 end), (if .premium then 0 else 1 end), .vcpus, .mem, .name)) as $others |
            ($preferred + $others)
          ' _skus.json > _candidates.json
          
          # Clean up
          rm -f _skus.json

          if [[ ! -s _candidates.json ]]; then
            echo "No matching VM sizes found in $REGION" >&2
            echo "best_size=" >> "$GITHUB_OUTPUT"
            echo "an_supported=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BEST_SIZE=$(jq -r '.[0].name' _candidates.json)
          AN=$(jq -r '.[0].an' _candidates.json)

          echo "best_size=$BEST_SIZE" >> "$GITHUB_OUTPUT"
          echo "an_supported=$AN" >> "$GITHUB_OUTPUT"
          
          echo "Debug: Best size found: $BEST_SIZE"
          echo "Debug: Candidates count: $(jq 'length' _candidates.json)"

          # Also export a short candidate list (top 6) for fallback attempts
          jq -r '.[0:6] | map(.name) | join("\t")' _candidates.json > _candidates.tsv
          echo "Debug: Fallback candidates:"
          cat _candidates.tsv
      
      - name: Create networking resources
        if: steps.pick-size.outputs.best_size != ''
        id: net
        shell: bash
        env:
          RG: ${{ env.RESOURCE_GROUP }}
          REGION: ${{ matrix.region }}
        run: |
          set -euo pipefail
          
          # Create VNet
          VNET="vnet-${REGION}"
          az network vnet create -g "$RG" -n "$VNET" -l "$REGION" \
            --address-prefix 10.0.0.0/16 >/dev/null
          echo "vnet=$VNET" >> "$GITHUB_OUTPUT"
          
          # Create Subnet
          SUBNET="subnet-${REGION}"
          az network vnet subnet create -g "$RG" --vnet-name "$VNET" \
            -n "$SUBNET" --address-prefix 10.0.0.0/24 >/dev/null
          echo "subnet=$SUBNET" >> "$GITHUB_OUTPUT"
          
          # Create NSG
          NSG="nsg-${REGION}"
          az network nsg create -g "$RG" -n "$NSG" -l "$REGION" >/dev/null
          
          # Add SSH rule
          az network nsg rule create -g "$RG" --nsg-name "$NSG" \
            -n allow-ssh --priority 100 --direction Inbound \
            --source-address-prefixes '*' --source-port-ranges '*' \
            --destination-address-prefixes '*' --destination-port-ranges 22 \
            --access Allow --protocol Tcp >/dev/null
          echo "nsg=$NSG" >> "$GITHUB_OUTPUT"
          
          # Create Public IP
          PIP="pip-${REGION}"
          az network public-ip create -g "$RG" -n "$PIP" -l "$REGION" \
            --sku Standard --allocation-method Static >/dev/null
          echo "pip=$PIP" >> "$GITHUB_OUTPUT"
      
      - name: Create NIC (Accelerated Networking if supported)
        if: steps.pick-size.outputs.best_size != ''
        id: nic
        shell: bash
        env:
          RG: ${{ env.RESOURCE_GROUP }}
          REGION: ${{ matrix.region }}
          VNET: ${{ steps.net.outputs.vnet }}
          SUBNET: ${{ steps.net.outputs.subnet }}
          PIP: ${{ steps.net.outputs.pip }}
          NSG: ${{ steps.net.outputs.nsg }}
          AN: ${{ steps.pick-size.outputs.an_supported }}
        run: |
          set -euo pipefail
          NIC="nic-${REGION}"
          if [[ "${AN}" == "true" ]]; then
            az network nic create -g "$RG" -n "$NIC" -l "$REGION" \
              --vnet-name "$VNET" --subnet "$SUBNET" \
              --network-security-group "$NSG" \
              --public-ip-address "$PIP" \
              --accelerated-networking true >/dev/null
          else
            az network nic create -g "$RG" -n "$NIC" -l "$REGION" \
              --vnet-name "$VNET" --subnet "$SUBNET" \
              --network-security-group "$NSG" \
              --public-ip-address "$PIP" >/dev/null
          fi
          echo "nic=$NIC" >> "$GITHUB_OUTPUT"
      
      - name: Create VM (with size fallback)
        if: steps.pick-size.outputs.best_size != ''
        id: vm
        shell: bash
        env:
          RG: ${{ env.RESOURCE_GROUP }}
          REGION: ${{ matrix.region }}
          NIC: ${{ steps.nic.outputs.nic }}
          DEFAULT_SIZE: ${{ steps.pick-size.outputs.best_size }}
          VM_IMAGE: ${{ env.VM_IMAGE }}
        run: |
          set -euo pipefail
          VM="latency-vm-${REGION}"

          if [[ -z "${DEFAULT_SIZE}" ]]; then
            echo "No suitable size discovered for ${REGION} — skipping."
            echo "skipped=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build candidate list: discovered top (DEFAULT_SIZE) + remaining from _candidates.tsv
          candidates=()
          candidates+=("$DEFAULT_SIZE")
          if [[ -f _candidates.tsv ]]; then
            # Read all candidates from the TSV file
            IFS=$'\t' read -r -a additional_candidates < _candidates.tsv || true
            for name in "${additional_candidates[@]}"; do
              if [[ -n "$name" && "$name" != "$DEFAULT_SIZE" ]]; then
                candidates+=("$name")
              fi
            done
          fi

          echo "Trying sizes in ${REGION}: ${candidates[*]}"

          attempt=0
          created=false
          for size in "${candidates[@]}"; do
            # Skip empty sizes
            if [[ -z "$size" ]]; then
              echo "Warning: Empty size value encountered, skipping..."
              continue
            fi
            
            attempt=$((attempt+1))
            echo "Attempt ${attempt}: size=${size}"
            set +e
            az vm create -g "$RG" -n "$VM" -l "$REGION" \
              --nics "$NIC" --image "$VM_IMAGE" \
              --size "$size" \
              --admin-username azureuser \
              --generate-ssh-keys >/tmp/vm_create.log 2>&1
            rc=$?
            set -e
            if [[ $rc -eq 0 ]]; then
              echo "VM created with size ${size}"
              created=true
              echo "size=${size}" >> "$GITHUB_OUTPUT"
              break
            fi

            # Inspect error for known transient/unsupported cases, then continue
            if grep -Eqi "SkuNotAvailable|AllocationFailed|OperationNotAllowed|Conflict|Insufficient|Overconstrained|Quota" /tmp/vm_create.log; then
              echo "Size ${size} failed due to availability/capacity/quota; trying next..."
              continue
            else
              echo "Unexpected failure creating VM with ${size}:"
              sed -n '1,200p' /tmp/vm_create.log
              # Attempt next anyway
            fi
          done

          if [[ "${created}" != "true" ]]; then
            echo "Could not create VM with any candidate size in ${REGION} — skipping."
            echo "skipped=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "skipped=false" >> "$GITHUB_OUTPUT"
          echo "vm=$VM" >> "$GITHUB_OUTPUT"
      
      - name: Run Latency Test
        if: steps.vm.outputs.skipped != 'true' && steps.pick-size.outputs.best_size != ''
        id: run-test
        uses: azure/cli@v2
        with:
          azcliversion: latest
          inlineScript: |
            set -e
            
            VM_NAME="${{ steps.vm.outputs.vm }}"
            
            echo "Installing dependencies on VM $VM_NAME in ${{ matrix.region }}..."
            
            echo "VM created successfully. Installing dependencies..."
            
            # Install Node.js, npm and clone the test repository
            INSTALL_SCRIPT='#!/bin/bash
            set -e
            
            # Update system
            sudo apt-get update -y
            
            # Install Node.js 20.x
            curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
            sudo apt-get install -y nodejs
            
            # Clone the test repository
            cd /home/azureuser
            if [ -n "${{ secrets.GH_PAT }}" ]; then
              git clone https://${{ secrets.GH_PAT }}@github.com/${{ github.repository }}.git
            else
              git clone https://github.com/${{ github.repository }}.git
            fi
            
            cd hl-test
            npm install
            
            # Create environment variables file
            cat > .env << EOF
            REDIS_URL=${{ env.REDIS_URL }}
            PRIVATE_KEY=${{ env.PRIVATE_KEY }}
            REGION=${{ matrix.region }}
            EOF
            
            # Run the latency test with region information
            export REDIS_URL="${{ env.REDIS_URL }}"
            export PRIVATE_KEY="${{ env.PRIVATE_KEY }}"
            export REGION="${{ matrix.region }}"
            node hyperliquid.js > /home/azureuser/output.log 2>&1
            '
            
            # Execute installation and test script
            az vm run-command invoke \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "$VM_NAME" \
              --command-id RunShellScript \
              --scripts "$INSTALL_SCRIPT" \
              --timeout 600 \
              --output none
            
            echo "Test execution completed. Retrieving results..."
            
            # Retrieve results
            OUTPUT=$(az vm run-command invoke \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "$VM_NAME" \
              --command-id RunShellScript \
              --scripts "cat /home/azureuser/output.log || echo 'No output file found'" \
              --query "value[0].message" \
              -o tsv)
            
            echo "Raw output from ${{ matrix.region }}:"
            echo "$OUTPUT"
            
            # Extract average latency
            AVG_LATENCY=$(echo "$OUTPUT" | grep -oP 'Average latency: \K[\d.]+' || echo "0")
            
            # Save results to file
            mkdir -p results
            echo "$OUTPUT" > "results/${{ matrix.region }}.txt"
            echo "${{ matrix.region }}:$AVG_LATENCY" > "results/${{ matrix.region }}.summary"
            
            echo "Average latency for ${{ matrix.region }}: ${AVG_LATENCY} ms"
            
            # Store VM size used for reporting
            echo "VM size used: ${{ steps.vm.outputs.size }}" >> "results/${{ matrix.region }}.txt"
            
            # Clean up all resources
            echo "Cleaning up resources..."
            
            # Delete VM
            az vm delete --yes --no-wait \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "$VM_NAME" \
              --output none
            
            # Delete NIC
            az network nic delete --no-wait \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ steps.nic.outputs.nic }}" || true
            
            # Delete Public IP
            az network public-ip delete --no-wait \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ steps.net.outputs.pip }}" || true
            
            # Delete NSG
            az network nsg delete --no-wait \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ steps.net.outputs.nsg }}" || true
            
            # Delete Subnet and VNet
            az network vnet subnet delete \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --vnet-name "${{ steps.net.outputs.vnet }}" \
              --name "${{ steps.net.outputs.subnet }}" || true
            
            az network vnet delete --no-wait \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ steps.net.outputs.vnet }}" || true
            
            echo "Resource cleanup initiated for ${{ matrix.region }}"
      
      - name: Handle Unavailable Region
        if: steps.pick-size.outputs.best_size == '' || steps.vm.outputs.skipped == 'true'
        run: |
          mkdir -p results
          echo "No suitable VM size available in region" > "results/${{ matrix.region }}.txt"
          echo "${{ matrix.region }}:999999" > "results/${{ matrix.region }}.summary"
      
      - name: Upload Region Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: results-${{ matrix.region }}
          path: results/
          retention-days: 7

  aggregate-results:
    needs: [latency-test]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: Aggregate Results
        run: |
          mkdir -p aggregated-results
          
          # Combine all region results
          for artifact_dir in artifacts/results-*/; do
            if [ -d "$artifact_dir" ]; then
              cp -r "$artifact_dir"/* aggregated-results/ 2>/dev/null || true
            fi
          done
          
          # Create comprehensive results file
          TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
          RESULTS_FILE="aggregated-results/LATENCY_RESULTS_${TIMESTAMP}.md"
          
          echo "# Azure Multi-Region Latency Test Results" > "$RESULTS_FILE"
          echo "" >> "$RESULTS_FILE"
          echo "**Test Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> "$RESULTS_FILE"
          echo "**Sequential Mode:** ${{ needs.setup.outputs.sequential }}" >> "$RESULTS_FILE"
          echo "" >> "$RESULTS_FILE"
          
          # Count successful regions
          SUCCESSFUL_REGIONS=$(find aggregated-results -name "*.summary" -exec grep -v ":999999$" {} \; | wc -l)
          echo "**Total Regions Tested:** $SUCCESSFUL_REGIONS" >> "$RESULTS_FILE"
          echo "" >> "$RESULTS_FILE"
          
          # Sort regions by latency
          echo "## Results Summary (Fastest to Slowest)" >> "$RESULTS_FILE"
          echo "" >> "$RESULTS_FILE"
          echo "| Rank | Region | Average Latency (ms) |" >> "$RESULTS_FILE"
          echo "|------|--------|---------------------|" >> "$RESULTS_FILE"
          
          # Process and sort results
          find aggregated-results -name "*.summary" -exec cat {} \; | \
            grep -v ":999999$" | \
            sort -t: -k2 -n | \
            nl -nln | \
            while IFS=: read -r rank region latency; do
              echo "| $rank | $region | $latency |" >> "$RESULTS_FILE"
            done
          
          echo "" >> "$RESULTS_FILE"
          echo "## Detailed Results by Region" >> "$RESULTS_FILE"
          echo "" >> "$RESULTS_FILE"
          
          # Add detailed results for each region
          for summary_file in aggregated-results/*.summary; do
            if [ -f "$summary_file" ]; then
              region=$(basename "$summary_file" .summary)
              latency=$(cat "$summary_file" | cut -d: -f2)
              
              echo "### $region" >> "$RESULTS_FILE"
              echo "" >> "$RESULTS_FILE"
              echo "**Average Latency:** ${latency} ms" >> "$RESULTS_FILE"
              echo "" >> "$RESULTS_FILE"
              
              # Add detailed output if available
              detail_file="aggregated-results/${region}.txt"
              if [ -f "$detail_file" ]; then
                echo '```' >> "$RESULTS_FILE"
                cat "$detail_file" >> "$RESULTS_FILE"
                echo '```' >> "$RESULTS_FILE"
                echo "" >> "$RESULTS_FILE"
              fi
            fi
          done
          
          # Update latest results
          cp "$RESULTS_FILE" aggregated-results/LATEST_RESULTS.md
          
          echo "Results aggregated successfully!"
          echo "Generated: $RESULTS_FILE"
      
      - name: Upload Aggregated Results
        uses: actions/upload-artifact@v4
        with:
          name: aggregated-results
          path: aggregated-results/
          retention-days: 30
      
      - name: Commit Results to Repository
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Copy results to test-results directory
          mkdir -p test-results
          cp aggregated-results/* test-results/
          
          # Commit and push
          git add test-results/
          git diff --staged --quiet || git commit -m "Update latency test results - $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          git push || echo "No changes to commit"